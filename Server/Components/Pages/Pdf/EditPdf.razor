@page "/edit-pdf"
@using EzeePdf.Core
@using EzeePdf.Core.Extensions
@using EzeePdf.Core.Responses
@rendermode InteractiveServer

@inject IPdfUsageService pdfUsageService;
@inject ISettingsService settingsService
@inject ISnackbar snackbar
@inject IJSRuntime jsRuntime;

<PageTitle>PDF Annotations</PageTitle>

<MudGrid>
    <MudItem xs="1">
        <MudPaper Class="pa-2" Style="height:calc(100vh - 70px); display: flex; flex-direction: column; align-items: center;">
            <MudFileUpload T="IBrowserFile"
                           Disabled="@downloadLimitReached"
                           FilesChanged="OnPdfFileSelected"
                           MaximumFileCount="1" Accept=".pdf">
                <ActivatorContent>
                    <MudTooltip Text="@downloadLimitReachedPdfMessage">
                        <MudIconButton Variant="Variant.Filled"
                                       Color="Color.Default"
                                       Icon="@Icons.Material.Outlined.PictureAsPdf">
                        </MudIconButton>
                    </MudTooltip>
                </ActivatorContent>
            </MudFileUpload>
            <br />
            <MudTooltip Text="Download">
                <MudIconButton Variant="Variant.Filled"
                               Color="Color.Default"
                               OnClick="OnSave"
                               Disabled="@(documentLoaded==false || errorMessage is not null)"
                               Icon="@Icons.Material.Filled.Download">
                </MudIconButton>
            </MudTooltip>

        </MudPaper>
    </MudItem>

    <MudItem xs="11">

        <div class="loader-container">
            <!-- Background Progress -->
            <MudProgressCircular Indeterminate="true" Class="loader-bg" />

            <!-- Foreground Control -->
            <SfPdfViewer2 @ref="@Viewer"
                          EnableFormFields="false"
                          EnablePrint="false"
                          EnableFormDesigner="false"
                          EnableDownload="@documentLoaded"
                          DownloadFileName="newfile.pdf"
                          Height="100%"
                          Width="100%">
                <PdfViewerEvents DocumentLoaded="DocumentLoaded"
                                 DownloadStart="OnDownloadStart"
                                 PrintStart="OnPrintStart">
                </PdfViewerEvents>
                <PdfViewerUnderlineSettings AllowedInteractions="@underlineAllowedInteractions" />

            </SfPdfViewer2>
        </div>
    </MudItem>

</MudGrid>


@code {
    private SfPdfViewer2? Viewer;
    private string? sourceDevice;
    private long pdfSize;
    private long allowedPdfSize;
    private long allowedPageCount;
    private bool documentLoaded;
    private string? errorMessage;
    private bool downloadLimitReached;
    private string? downloadLimitReachedPdfMessage = "Select PDF";
    private string? ipAddress;
    private bool customUploadCalled;
    private bool customSaveCalled;

    private List<AllowedInteraction> underlineAllowedInteractions = [
            AllowedInteraction.Select,
            AllowedInteraction.Move,
            AllowedInteraction.Resize,
            AllowedInteraction.Delete
    ];

    private async Task OnPdfFileSelected(IBrowserFile e)
    {
        customUploadCalled = true;

        await AddUpload(e.Size, e.Name);

        await Viewer!.UnloadAsync();
        errorMessage = null;
        documentLoaded = false;
        if (e.Size > allowedPdfSize)
        {
            errorMessage = $"Pdf file size ({e.Size.BytesToMb()} KB) exceeded allowed value: {allowedPdfSize.BytesToMb()} MB";
            snackbar.Add(errorMessage, Severity.Error);
            await Viewer!.UnloadAsync();
        }
        else
        {
            pdfSize = e.Size;
            using var stream = e.OpenReadStream(maxAllowedSize: allowedPdfSize);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var bytes = ms.ToArray();
            await Viewer!.LoadAsync(bytes);
        }
    }
    private async Task AddUpload(long size, string? fileName)
    {
        var response = await pdfUsageService.AddUpload(null,
                    Core.Enums.EnumPdfFunction.Watermark,
                    sourceDevice,
                    size,
                    fileName,
                    ipAddress);

        if (response.Code == EnumResponseCode.DailyUploadLimitReached)
        {
            downloadLimitReached = true;
            downloadLimitReachedPdfMessage = response.ErrorMessage;
            snackbar.Add(downloadLimitReachedPdfMessage!, Severity.Error);
            StateHasChanged();
        }
    }
    private async void OnSave(MouseEventArgs args)
    {
        var doc = await Viewer!.GetDocumentAsync();
        if (doc is null)
        {
            snackbar.Add("Sorry! there was some issue with document, please reload", Severity.Warning);
        }
        else
        {
            var response = await pdfUsageService.SaveUsage(null,
                            Core.Enums.EnumPdfFunction.Editing,
                            sourceDevice,
                            Viewer!.PageCount,
                            pdfSize,
                            doc.Length,
                            ipAddress);
            if (response.Success)
            {
                customSaveCalled = true;
                await Viewer!.DownloadAsync();
            }
            else
            {
                snackbar.Add(response.ErrorMessage!, Severity.Error);
            }
        }
    }
    private async void DocumentLoaded(LoadEventArgs e)
    {
        if (downloadLimitReached)
        {
            await Viewer!.UnloadAsync();
            documentLoaded = false;
            errorMessage = $"Application uploaded/download limit reached, please try next day (UTC)";
            snackbar.Add(errorMessage, Severity.Error);
        }
        else if (!customUploadCalled)
        {
            await Viewer!.UnloadAsync();
            documentLoaded = false;
            errorMessage = $"Unauthorized access, use custom upload button";
            snackbar.Add(errorMessage, Severity.Error);
        }
        else if (Viewer!.PageCount > allowedPageCount)
        {
            documentLoaded = false;
            errorMessage = $"Pdf file page count ({Viewer.PageCount}) exceeded allowed value: {allowedPageCount}";
            snackbar.Add(errorMessage, Severity.Error);
            await Viewer!.UnloadAsync();
        }
        else
        {
            documentLoaded = true;
        }
        customUploadCalled = false;
    }

    private async void OnDownloadStart(DownloadStartEventArgs args)
    {
        if (!customSaveCalled)
        {
            await Viewer!.UnloadAsync();
            errorMessage = "Unauthorized access, use custom download button";
            snackbar.Add(errorMessage, Severity.Error);
        }
        customSaveCalled = false;
    }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender)
        {
            allowedPdfSize = await settingsService.PdfMaxPdfFileSize();
            allowedPageCount = await settingsService.MaxAllowedPageCount();
            sourceDevice = await jsRuntime.InvokeAsync<string>("eval", "navigator.userAgent");
            var downloadReached = await pdfUsageService.DailyLimitReached();
            if (downloadReached.Code == EnumResponseCode.DailyUploadLimitReached)
            {
                downloadLimitReached = true;
                downloadLimitReachedPdfMessage = downloadReached.ErrorMessage;
                snackbar.Add(downloadLimitReachedPdfMessage!, Severity.Error);
                StateHasChanged();
            }
            try
            {
                ipAddress = await jsRuntime.InvokeAsync<string>("getPublicIp");
                StateHasChanged();
            }
            catch
            {
            }
        }
    }
    private async void OnPrintStart(PrintStartEventArgs args)
    {
        await Viewer!.UnloadAsync();
    }
}
