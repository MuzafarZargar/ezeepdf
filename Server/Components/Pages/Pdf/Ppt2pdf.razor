@page "/pdf-tools/ppt2pdf"

@rendermode InteractiveServer

@using EzeePdf.Core
@using EzeePdf.Core.Extensions
@using EzeePdf.Core.Responses
@using Syncfusion.Pdf
@using Syncfusion.Pdf.Graphics
@using Syncfusion.Pdf.Parsing
@using Syncfusion.Presentation
@using Syncfusion.PresentationRenderer

@inject ILogService logService
@inject ISettingsService settingsService
@inject IPdfUsageService pdfUsageService;
@inject IJSRuntime jsRuntime
@inject IDialogService DialogService
@inject ISnackbar snackbar

<PageTitle>PowerPoint to PDF</PageTitle>
<meta name="description" content="PowerPoint to PDF: Converts PPTX to PDF" />

<MudGrid>
    <MudItem xs="1">
        <MudPaper Class="pa-2" Style="height:calc(100vh - 60px); display: flex; flex-direction: column; align-items: center;">

            <MudFileUpload T="IBrowserFile"
                           Disabled="@downloadLimitReached"
                           FilesChanged="OnPPTFileOpen"
                           MaximumFileCount="1" Accept=".pptx">
                <ActivatorContent>
                    <MudTooltip Text="@downloadLimitReachedPdfMessage">
                        <MudIconButton Variant="Variant.Filled"
                                       Color="Color.Default"
                                       Icon="@Icons.Material.Outlined.PictureAsPdf">
                        </MudIconButton>
                    </MudTooltip>
                </ActivatorContent>
            </MudFileUpload>
            <br />

            <br />
            <MudTooltip Text="Download">
                <MudIconButton Variant="Variant.Filled"
                               Color="Color.Default"
                               OnClick="OnSave"
                               Disabled="disableSaveButton"
                               Icon="@Icons.Material.Filled.Download">
                </MudIconButton>
            </MudTooltip>
            <br />

        </MudPaper>
    </MudItem>

    <MudItem xs="11">
        <div class="loader-container">
            <!-- Background Progress -->
            <MudProgressCircular Indeterminate="true" Class="loader-bg" Color="Color.Info" />

            <!-- Foreground Control -->
            <SfPdfViewer2 @ref="@Viewer"
                          EnableToolbar="false"
                          DownloadFileName="Presentation.pdf"
                          Height="100%"
                          Width="100%">
                <PdfViewerEvents DocumentLoaded="OnDocumentLoaded"
                                 DocumentUnloaded="OnDocumentUnloaded">
                </PdfViewerEvents>
            </SfPdfViewer2>
        </div>
    </MudItem>
</MudGrid>


@code {

    private SfPdfViewer2? Viewer;
    private string? errorMessage;
    private string? sourceDevice;
    private long allowedPdfSize;
    private long pdfSize;
    private bool downloadLimitReached;
    private string? downloadLimitReachedPdfMessage = "Select PPT";
    private bool documentLoaded;
    private bool disableSaveButton = true;
    private string? ipAddress;
    private string? originalFileName;

    private async Task OnPPTFileOpen(IBrowserFile e)
    {
        originalFileName = e.Name;
        await AddUpload(e.Size, e.Name);

        await Viewer!.UnloadAsync();
        errorMessage = null;

        if (e.Size > allowedPdfSize)
        {
            errorMessage = $"PowerPoint file size ({e.Size.BytesToMbWithDecimal("#0")} MB) exceeded allowed value: {allowedPdfSize.BytesToMbWithDecimal("#0")} MB";
            snackbar.Add(errorMessage, Severity.Error);
            await Viewer!.UnloadAsync();
        }
        else
        {
            try
            {
                using (MemoryStream memoryStream = new MemoryStream())
                {
                    using (var pptStream = e.OpenReadStream(maxAllowedSize: allowedPdfSize))
                    {
                        await pptStream.CopyToAsync(memoryStream);
                        memoryStream.Position = 0;
                        using (IPresentation pptxDoc = Presentation.Open(memoryStream))
                        {
                            using (PdfDocument pdfDocument = PresentationToPdfConverter.Convert(pptxDoc))
                            {
                                using (var ms = new MemoryStream())
                                {
                                    pdfDocument.Save(ms);
                                    ms.Seek(0, SeekOrigin.Begin);
                                    await Viewer!.UnloadAsync();
                                    await Viewer.LoadAsync(ms);
                                }
                            }
                        }
                    }
                }
                pdfSize = e.Size;
            }
            catch (Exception ex)
            {
                errorMessage = ex.Message;
                snackbar.Add(ex.Message, Severity.Error);
            }
        }
        EnableSaveButton();
    }
    private async Task AddUpload(long size, string? fileName, DataResponse? response = null)
    {
        response ??= await pdfUsageService.AddUpload(null,
                    Core.Enums.EnumPdfFunction.PptToPdf,
                    sourceDevice,
                    size,
                    fileName,
                    ipAddress);
        if (response.Code == EnumResponseCode.DailyUploadLimitReached)
        {
            downloadLimitReached = true;
            downloadLimitReachedPdfMessage = response.ErrorMessage;
            snackbar.Add(downloadLimitReachedPdfMessage!, Severity.Error);
            StateHasChanged();
        }
    }
    private async void OnSave(MouseEventArgs args)
    {
        var doc = await Viewer!.GetDocumentAsync();
        if (doc is null)
        {
            snackbar.Add("Sorry! there was some issue with document, please reload", Severity.Warning);
        }
        else
        {
            var response = await pdfUsageService.SaveUsage(originalFileName ?? "pptx.pdf", null,
                            Core.Enums.EnumPdfFunction.PptToPdf,
                            sourceDevice,
                            Viewer!.PageCount,
                            pdfSize,
                            doc.Length,
                            ipAddress);
            if (response.Success)
            {
                await Viewer!.DownloadAsync();
                await AddUpload(0, string.Empty, response);
            }
            else
            {
                snackbar.Add(response.ErrorMessage!, Severity.Error);
            }
        }
    }
    private void EnableSaveButton()
    {
        disableSaveButton = !documentLoaded || errorMessage is not null;
        StateHasChanged();
    }
    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender)
        {
            allowedPdfSize = await settingsService.PPTMaxFileSize();
            sourceDevice = await jsRuntime.InvokeAsync<string>("eval", "navigator.userAgent");
            var downloadReached = await pdfUsageService.DailyLimitReached();
            if (downloadReached.Code == EnumResponseCode.DailyUploadLimitReached)
            {
                downloadLimitReached = true;
                downloadLimitReachedPdfMessage = downloadReached.ErrorMessage;
                snackbar.Add(downloadLimitReachedPdfMessage!, Severity.Error);
                StateHasChanged();
            }
            try
            {
                ipAddress = await jsRuntime.InvokeAsync<string>("getPublicIp");
                StateHasChanged();
            }
            catch
            {
            }
        }
    }
    private async void OnDocumentLoaded(LoadEventArgs args)
    {
        if (downloadLimitReached)
        {
            await Viewer!.UnloadAsync();
        }
        else
        {
            documentLoaded = true;
        }
        EnableSaveButton();
    }
    private void OnDocumentUnloaded(UnloadEventArgs args)
    {
        documentLoaded = false;
        EnableSaveButton();
    }
}